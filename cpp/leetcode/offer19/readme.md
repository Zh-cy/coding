> 请实现一个函数用来匹配包含`'. '`和`'*'`的正则表达式。模式中的字符`'.'`表示任意一个字符，而`'*'`表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串`"aaa"`与模式`"a.a"`和`"ab*ac*a"`匹配，但与`"aa.a"`和`"ab*a"`均不匹配。

## 第一次解题想法（误）

用**递归**的方法，从s的每一个字符为基准，用p中的字符对s中的字符进行匹配。

使用s来代表当前s中的字符串，s+1是s的后一个字符串，s-1是前一个字符串

***匹配分成以下几中情况：***

* s != p && p != '*' && p != '.'
  * p+1 == '*' -> 对 s和p+2进行递归
  * p+1 != '*' -> false
* s != p && p == '*' -> true
* (s != p && p == '*') || s == p
  * p+1 == '*'
    * s+1 == s -> 对 s+1和p进行递归
    * s+1 != s ->对 s+1和p+2进行递归
  * p+1 != '*' ->对 s+1和p+1进行递归

多种case无法通过，比如

```
s = "aaa", p = "a*a"
s = "asdfvda", p = ".*a"
```



## 正确题解

使用**动态规划**，分别针对s和p的最后一个字符进行分析，之后与前面的子问题一起得到true或false

注意如果s的字符串长度为m，p字符串长度为n

因为要考虑到空字符串的情况，dp的二维数组的维度应该为(m+1, n+1)，最后的结果为`dp[m][n]`

`s[i-1]`代表当前s中的字符串，`s[i]`是s的后一个字符串，`s[i-2]`是前一个字符串

***1. 情况划分：***

转移方程： 需要注意，由于` dp[0][0] `代表的是空字符的状态， 因此` dp[i][j] `对应的添加字符是` s[i - 1] 和 p[j - 1] `

* 当`p[j - 1] != '*'` 时， `dp[i][j] `在当以下任一情况为 true 时等于 true ：
  * `dp[i - 1][j - 1] `且 `s[i - 1] = p[j - 1]`： 即让字符 `p[j - 1]`多出现一次时，能否匹配；
  * `dp[i - 1][j - 1]`且 `p[j - 1] = '.'`： 即将字符`'.'` 看作字符 `s[i - 1] `时，能否匹配；

* 当` p[j - 1] == '*' `时， `dp[i][j] `在当以下任一情况为 true 时等于true ：
  * `dp[i][j - 2]`： 即将字符组合 `p[j - 2]`和`* `看作出现 0 次时，能否匹配；
  * `dp[i - 1][j] `且 `s[i - 1] = p[j - 2]`: 即让字符 `p[j - 2]` 多出现 1 次时，能否匹配；
  * `dp[i - 1][j] `且 `p[j - 2] = '.'`: 即让字符` '.' `多出现 1 次时，能否匹配

***2. 状态转移方程***

* `p[j-1] != '*' `

  `dp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.')`

* `p[j-1] == '*' `

  `dp[i][j] = dp[i][j - 2] || dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`

***3. 初始条件***

`dp[0][0] == true` 两个空字符串

`dp[i][0] == false` s不空，p空

`dp[0][j] == dp[0][j-2] && p[j-1] == '*'` s空，p的偶数位`p[j-1]`是`'*'`，那么，`p[j-1]`（当前偶数位）跟前面的字符可以组合为空

**注意：这里别把前面已经初始化好了的`dp[0][0]`给该成false了** 

***4.代码***

```cpp
bool isMatch(string s, string p) {
    int m = s.size();
    int n = p.size();
    vector<vector<bool>> dp(m+1, vector<bool>(n+1, false));
    dp[0][0] = true;
    for (int i=2; i<n+1; i+=2)
        dp[0][i] = dp[0][i-2] && p[i-1] == '*';
  
    for(int i=1; i<m+1; i++)
    {
        for (int j=1; j<n+1; j++)
        {
            if (p[j-1] != '*')
                dp[i][j] =  dp[i-1][j-1] && (s[i-1]==p[j-1] || p[j-1] == '.');
            else
                dp[i][j] = (dp[i][j - 2]) || (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));
        }
    }
    return dp[m][n];
}
```

