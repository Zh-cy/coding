A.暴力法
用链表来模拟，一共要删除n-1个数字，每次都要移动m步来进行删除数字
时间复杂度为O(mn)，这是无法忍受的

B.数学法
先摆出公式: f(m,n) = (f(n-1,m) + m) % n
例如一共有6个数字，每3个数字删除一个即
第一轮 0 1 **2** 3 4 5
第二轮 3 4 **5** 0 1
第三轮 0 1 **3** 4
第四轮 4 0 **1**
第五轮 4 0 **4** 0
最终轮 0

可以得知，最后剩下的数字是0，通过公式来验证一下
最终轮f(1,3): 只剩下一个数字，那么它就是最后数字，index是0
第五轮f(2,3): (f(1,3)+3)%2 = 3%2 = 1
第四轮f(3,3): (f(2,3)+3)%3 = 4%3 = 1
第三轮f(4,3); (f(3,3)+3)%4 = 4%4 = 0
第二轮f(5,3): (f(4,3)+3)%5 = 3%5 = 3
第一轮f(6,3): (f(5,3)+3)%6 = 6%6 = 0

由于每一轮都要删除第m个数字，之后这个被删除的数字的下一个作为新的头部数字开始新的一轮
所以，相当于每过一轮之后，所有的数字的下标都会向前移动m位
那么，对于最终剩下的数字来说就也是这样
每过一轮，它的下标就会向前移动m位
---------------以上是论述过程--------------------
那么如果要进行解题要逆向来看
最终轮剩下的数字下标都肯定是0,然后向上逆推
利用公式 f(m,n) = (f(m-1,n) + m) % n 求出上一轮的数字下标

int lastRemaining(int n, int m)
{
	int index = 0;
	for (int i=2; i<=n; i++)
	{
		index = (index+m)%i;
	}
	return index;
}
